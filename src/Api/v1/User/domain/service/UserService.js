const prisma = require( '../../../Shared/domain/database/PrismaCliente' );
const ErrorServiceHandler = require( '../../../Shared/domain/Handler/ErrorServiceHandler' );
const FilterOrOrderAdapter = require( '../../../Shared/domain/Handler/FilterOrOrderAdapter' );

/**
 * * Service class for managin user information.
 *  Provides methods to create, delete , update and retrieve user data.
 * @class UserService
 */
class UserService {

    /**
     * Constructor for UserService.
     * 
     * @param { object } UserRepository - Repository to interact with the user data.
     * @param { object } AddressUserRepository - Repository to interact with the address user data.
     */
    constructor( UserRepository, AddressUserRepository ) {
        this.UserRepository = UserRepository;
        this.AddressUserRepository = AddressUserRepository

    }

    /**
     * Create a new user address.
     * 
     * @param {object} userData - The data of the address to be created.
     * @param {string} userData.email
     * @param {string} userData.username
     * @param {string} userData.image_profile - The image route that is used by user.
     * @param {string} userData.password - The user password encrypt.
     * @param {string} userData.google_sign - If the user was sign up by google api.
     * @param {string} userData.token - The token that was generated by the user.
     * @param {string} userData.refresh_token - The refresh token that was generated by the user.
     * @param {int}    userData.id_rol - The role that user belong.
     * @param {object} userData.profile - The profile information of the user
     * @param {object} userData.address - The user address that belong.
     * @returns {Promise<object>} - The created user.
     * @throws Will throw an error if user creation fails.
     */
    async createUser({ email, username, image_profile, password, google_sign, token, refresh_token, id_rol, profile, address }){
        try{
            const result = await prisma.$transaction(async (prisma) => {
                 const user = await this.UserRepository
                    .createUser( 
                        prisma, 
                        email, 
                        username, 
                        image_profile === null ? 'default' : image_profile, 
                        password, 
                        profile.first_name, 
                        profile.last_name, 
                        profile.birth_day, 
                        google_sign, 
                        token, 
                        refresh_token, 
                        id_rol 
                    );

                await this.AddressUserRepository
                    .createAddressUser( 
                        prisma, 
                        address.street, 
                        address.city, 
                        address.state, 
                        address.zip_code, 
                        address.country, 
                        user.id_user 
                    );
                
                return true;
            
            });

            return result;

        } catch ( error ) {
            ErrorServiceHandler._handleError(error, 'Error when trying to create a user.', 'UserLogger');
        }

    }

    /**
     * Deletes a user as an user (soft delete).
     *
     * @param {object} query - The data required for deletion.
     * @param {string} query.uuid - UUID of the user to be deleted.
     * @returns {Promise<object>} - Result of the deletion operation.
     * @throws Will throw an error if user deletion fails.
     */
    async deleteUser({ uuid }) {
        try{
            const result = await prisma.$transaction(async (prisma) => {
                return await this.UserRepository.deleteUser( prisma, uuid );
            });

            return result;

        } catch ( error ) {
            ErrorServiceHandler._handleError(error, 'Error when trying to delete a user.', 'UserLogger');
        }
    }

    /**
     * Updates a user.
     *
     * @param {object} userData - The data of the address to be created.
     * @param {string} userData.email
     * @param {string} userData.username
     * @param {string} userData.image_profile - The image route that is used by user.
     * @param {string} userData.password - The user password encrypt.
     * @param {string} userData.google_sign - If the user was sign up by google api.
     * @param {string} userData.token - The token that was generated by the user.
     * @param {string} userData.refresh_token - The refresh token that was generated by the user.
     * @param {int}    userData.id_rol - The role that user belong.
     * @param {object} userData.profile - The profile information of the user
     * @param {object} userData.address - The user address that belong.
     * @returns {Promise<object>} - The created user.
     * @throws Will throw an error if user creation fails.
     */
    async updateUser({ uuid_user, email, username, image_profile, password, google_sign, token, refresh_token, id_rol, profile, address }) {
        try {
            const result = await prisma.$transaction(async (prisma) => {
                await this.UserRepository
                    .updateUser( 
                        prisma, 
                        uuid_user,
                        email, 
                        username, 
                        image_profile === null ? 'default' : image_profile, 
                        password, 
                        profile.first_name, 
                        profile.last_name, 
                        profile.birth_day, 
                        google_sign, 
                        token, 
                        refresh_token, 
                        id_rol 
                    );

                await this.AddressUserRepository
                    .updateAddressUser( 
                        prisma, 
                        address.uuid_address_user,
                        address.street, 
                        address.city, 
                        address.state, 
                        address.zip_code, 
                        address.country, 
                        uuid_user 
                    );
                
                return true;
            });

            return result;
        } catch ( error ) {
            ErrorServiceHandler._handleError(error, 'Error when trying to update a user.', 'UserLogger');
        }
    }

    /**
     * Fetch a user by UUID.
     *
     * @param {object} query - The query of the URL to send the information.
     * @param {string} query.uuid - UUID of the user to retrieve.
     * @returns {Promise<object>} - The user data.
     * @throws Will throw an error if retrieval fails.
     */
    async getUserByUuid({ uuid }) {

        try{
            return await this.UserRepository.getUserByUuid( uuid );

        } catch ( error ) {
            ErrorServiceHandler._handleError(error, 'Error when trying to get a user by uuid.', 'UserLogger');
        }

    }

    /**
     * Fetch a user by email.
     *
     * @param {object} query - The query of the URL to send the information.
     * @param {string} query.email - Email of the user to retrieve.
     * @returns {Promise<object>} - The user data.
     * @throws Will throw an error if retrieval fails.
     */
    async getUserByEmail({ email }) {
        try {
            return await this.UserRepository.getUserByEmail( email );
        
        } catch ( error ) {
            ErrorServiceHandler._handleError(error, 'Error when trying to get a user by email.', 'UserLogger');
        }

    }

    /**
     * Fetch paginated user
     * @param {int} page - The page number 
     * @param {int} size - The size of items per page
     * @param {array} orderBy  - The field that applied a order by
     * @param {array} filter - The fields that applied the filter
     * @returns {Promise<object[]>} - The paginated list of users.
     * @throws Will throw an error if pagination fails.
     */
    async getUsersByPagination({ page, size, orderBy, filter }) {

        try{
            const skip = ( page - 1 ) * size;

            // Create field mappings to handle both orderBy and filter cases
            const validFields = {
                email: 'email',
                username: 'username',
                first_name: 'first_name',
                last_name: 'last_name',
                birth_day: 'birth_day',
                user_create: 'user_create',
                id_rol: {
                    tbl_rol: 'id_rol' // Nested relation for Prisma orderBy
                }
            };

            const orderByAdapter = FilterOrOrderAdapter.buildOrderBy(validFields, orderBy);
            const filterAdapter = FilterOrOrderAdapter.buildFilter(validFields, filter);

            const [ data, count ] = await this.UserRepository.getUsersByPagination( skip, size, orderByAdapter, filterAdapter );

            return {
                data, 
                count,
                page,
                size
            }

        } catch ( error ) {
            ErrorServiceHandler._handleError(error, 'Error when trying to paginate a list user.', 'UserLogger');
        }

    }

}

module.exports = UserService;